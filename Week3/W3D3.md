# Bubbling and Capturing in Javascript

Javascript has something called event propagation, which essentially is how the event flows through the elements on the page

There are two ways in which an event can propagate, the first is called bubbling and the second is called capturing

## Event Bubbling

Bubbling is the default propagation strategy for event listeners
- Follow a buttom up approach
- The event starts at the target element and "bubbles" its way up to the html tag

Bubbling works for all handlers, reguardless of how they were registered

## Event Capturing

Event capturing is the opposite of bubbling, you start at the html tag, and work your way down to the taget tag
- Following a top to bottom

Capturing only works with event listeners that are registered with the .addEventListener with the added third argument set to true

# Operators and Control Flow

Javascript operators perform some operations on a single or multiple operands and produce a result

There are five types of operators in Javascript
- Arithmetic -, +, `*`, /, %, ++, --
- Comparison: ==, ===, !=, >, <. >=, <=
- Logical: &&, ||, !
- Assignment: =, +=, -=, `*=`, /=, %=
- Ternary: condition ? true : false

Control Flow:

- if/else
- for
- for in
    - Enhanced for loop which loops through the properties of an object
- for of
    - Enhanced for loop which loops through the elements of an array
- while
- do while

# Type Coercion

the process of converting a value from one datatype to another datatype

There are two types of type coercion, explicit and implicit

- Explicit occurs when we specify it to happen
    - `var num = new Number("3")`
- Implicit occurs automatically by Javascript, it happen some times when javascript is attempting to carry out some instruction
    - `var div = "3"/4`

## Differcent between == and ===

They are used to compare object in Javascript
- == compares two values and does not take into account their types
- == essentially performs type coercion to see if the values being compared are the same
- === compare the two values and will check strictly against their types and their values
- === will only return true if the value AND the types are the same

### TLDR: === does strict comparison, type and value must equals, == only compares the value

## Truthy and Falsy in Javascript

In Javascript any expression or value that results in a boolean false is considered falsy, these include:

- boolean false
- empty string ''
- Undefined
- null
- Nan
- 0

Everything else is truthy

# Variable Scopes

The scope of a variable defines the lifetime and visibility of a variable in Javascript
- The variable cannot be access outside of its scope

Two major types of scope: Global and Local

## Global Scope

accessible everywhere in the application/script it has the lifetime of that application

## Local Scope

accessible only in their location

Local scope is broken into function and block

## Function Scope:

variables declared inside of a function, they are only accesible inside of said function, and no longer exist after the function is complete

## Block Scope:

Introduced in ES6, along with the variable keywords `let` and `const`, and these can only be access from inside their block of code, and the lifespan is the life of that block of code.

However, before ES6, there was no "block" scope because of hoisting

# Hoisting:

variable and function declarations are hoisted/moved to the top their scope before code execution

- Only the declarations are hoisted, not the assignments
    - `var d;` this gets hoisted
    - `d = 100` this does not get hoisted
- Any variables inside of block with the `var` keyword, will be hoisted into function scope

# let and const keywords

let and const were introduced in ES6 as means of preventing hoisting from block scope
- It appears from our experimentation, that these are preventing all hoisting

The let keyword allows you to declared a variable in block scope without it being hoisted
- Act just as a var would

The const keyword allows you to declare a variable in block scope, however it acts as a constant, so once assigned, you cannot reassign

It is now considered best practice to use let and const instead of var everywhere in your program

## Function Expressions:

known as anonymous functions, have no identifier/name, and are stored in a variable.

This is once again possible in Javascript, because functions are objects

- example: `let hello = function(){console.log('hello')}`

## Arrow functions

- a new simplified way to write function expressions
- looks like lambdas: `let hello = () => console.log('hello')`
- `let name = (params) => {logic}`
- You call these just like any other function `hello()` => print out hello

## Immediately Invoked Function Expression (IIFE), these are anonymous functions that get called as soon as they are created

To do this, we wrap the function in a set of parenthesis, with a second set to call the function

```javascript
(let func = (params) => {
    some logic in here
    return l;
})();
```

## Template Literals

Template literals are an easy way to create multi-line strings and perform string interpolation
- These are string enclosed in backticks `
- It allows for embedded expressions, placeholders indicated by a dollar sign and curly braces
- ```javascript
  let s = 10;
  console.log(`We have ${s} assignments due this semester`);
  ```
- This will output: "We have 10 assignments due this semester"

## `this` keyword

The `this` keyword has several meanings depending on where its used
- `this` alone refers to the global window object
- `this` in event handers refers to the HTML element that receives the event
- `this` in object method binding refers to the object